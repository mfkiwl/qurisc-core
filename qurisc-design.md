
# QuSim 设计文档

QuSim的具体设计文档。
该文档说明QuSim的所有部件的属性，包括系统的总体结构、各个部件的属性、部件的状态时序要求以及实现时的注意事项等。

##  设计原则
以下介绍QuSim用到的主要的设计原则。其中，有一些设计原则是贯穿始终的（例如乱序执行以提高ILP的原则），另外一些设计原则可能只是应用于具体的部件（例如前端异步流水线原则）。在提及具体部件的设计时，我们还会引用这些原则。

### 乱序执行
QuSim被设计成支持乱序执行以提高ILP（Instruction Level Parallelism）。具体而言，为了在乱序执行的同时保证对精确异常和中断的支持，QuSim采用了Tomasulo with Reorder Buffer算法，通过“顺序发射、乱序执行、顺序提交”，允许异常和中断的精确处理。
乱序执行的硬件设计远比顺序流水线结构复杂，会带来一系列设计上的挑战，同时会遇到顺序流水线中不存在的冲突问题。例如：
- 访存时的内存访问顺序与内存重命名（Memory Disambiguation）。
- 内存模型。一些Load操作必须是强顺序的。
- 乱序执行中的全局状态，例如CSR寄存器。
- 复杂的逻辑带来较大的门延迟，限制主频进一步提升。

我们会在各个部件的设计中提及如何解决这些问题。
#### Load Speculation
Load Speculation允许我们在Store的地址尚未确定的时候就执行Load操作，从而所有的内存Load操作都不会遇到阻塞；然而这样的Load Speculation可能会失败，此时我们需要回滚已有的操作。简单的策略是视为分支预测失败并Flush ROB，但是会带来严重的效率损失。我们采用一种“重发射”的方法，对受到影响的指令进行精确重放。

- 指令数据依赖关系：假如后一条指令需要前一条指令的计算结果，那么我们称后一条指令依赖于前一条指令。我们可以发现，一条指令需要被重新计算，当且仅当这条指令间接依赖了错误的Load。
- 指令数据依赖关系的确定和存储：我们使用一个Mask来表示ROB表项之间的依赖关系。一条指令的Target的Mask等于指令的Operands的Mask之或（将Mask同时存储在重命名表里可以降低查找ROB的延迟）。当ROB表项正确提交时，依赖关系消失，所有的Mask抹去依赖关系中的这一位。
- 预测读取失败：当我们发现一条Load指令失败时，我们可以确定需要重新发射的指令的集合。此时，ROB进入一种“重发射”的状态：
	- 保留站中包含当前指令的Mask：需要被取消的计算会被取消。（I/O operation一定没有超过PNR，所以可以被安全取消。）
	- LQ/SQ中所有元素被记为无效。
	- 重命名站被清空。
	- ROB从错误的Load指令开始，要求Dispatcher重新分发每一条指令：对于所有的指令，重命名站和Mask会被重新设置，LQ/SQ会被重新设置为有效；但是当遇到不需要重新发射的指令时，保留站不做任何操作，LQ/SQ不需要清空操作。
	- 当最后一条指令被分发完毕时，重发射状态结束，继续正常指令发射。
- 重发射状态可以被重入：在重发射时，假如再次发现Load Speculation Fail，则再次从开始重新发射。
- 重发射状态可以被打断：清空ROB的条件不变。

### AXI总线协议
QuSim使用AXI总线协议，对内存和外设进行操作。
AXI总线协议的特点：
- 通过若干个Channel（读地址、读数据、写地址、写数据、写完成）提供以Burst为单位的外设访问。完整的Slave实现较为可能复杂，但Master实现比较简单。
- 与Xilinx系列IP核高度兼容（例如可以直接由AXI协议访问Block RAM/ROM、PS控制的DRAM、封装的GPIO等）。
- Xilinx提供AXI Interconnect以实现总线复用等功能。

基于以上原因，我们使用AXI总线协议与外设进行交互。

QuSim使用了以下的Master：
- L1 DCache/ICache，可以用总线读取数据或者向总线写回数据。
- Page Table Walker，硬件直接从总线访问页表。

QuSim需要使用以下的Slave：
- GPIO，控制状态指示灯和开关等。
- SRAM。尽管理论上SRAM可以在一个周期内完成读或写操作，但是由于需要等待状态稳定，SRAM也可以通过Burst操作来减少状态转移带来的效率损失（2周期读1次->9周期读8次）。
- 串口。

### 前端：异步流水线
QuSim的前端流水线由PC、TLB、访存、分支预测、指令队列等部分组成。这些流水线级具有以下特点：
- 需要的周期数长于一周期且不定：TLB段可能需要Page Table Walk，访存段可能遇到Cache Miss，指令序列可能会被重发射阻塞。
- 可能会被打断，但是不能简单重置：例如，可能在访存段访总线的时候发现分支预测失败，但是AXI协议不支持操作的取消。
- 操作可以认为是无副作用的：分支预测（尤其是RAS的维护）可以回滚，Cache的误操作和TLB的误读取不会造成本质问题。

受到AXI协议的启发，QuSim要求前端的各个流水段作为“异步流水线”：
- 流水段支持的接口：clk, rst, in_ready, in_valid, din, out_ready, out_valid, cancel。
- 流水段之间的数据通信必须经过类似AXI Channel的握手才能进行。这允许“后面的流水段阻塞反馈到前面的流水段”的类似功能。
- 流水段总会完成一整个操作，但是假如流水段在完成这个操作的中间收到了一个取消信号（例如，分支预测失败清空前端流水线），那么它将不会向下一个流水段发射运算结果。

这样的异步流水线的行为可以用以下的状态转移模型来描述：
- 异步流水线内除了计算单元，还包括一个和dout等大的dout_store和一个cancelled寄存器。
- 闲置态：当流水段被Reset时进入这个状态。此时in_ready=1，out_valid=0。当in_valid为1时，进入计算态，cancelled设为0；否则停留在闲置态。
- 计算态：试图完成流水线需要的计算。计算可能只需要一个周期，也可能需要多个周期。
为了节约周期数，在计算的最后一个周期，直接将out_valid设为1：假如此时out_ready也为1，则将in_ready也设为1，下一个周期直接进行下一轮计算。
在计算态的任何周期内，假如cancel被设为1，则cancelled置1，之后out_valid不再设为1，并且允许将in_ready置为1（如同本轮计算结果被下一级流水线吸收了）尽早开始下一轮计算。
假如在计算的最后一个周期，这轮操作没有被取消而out_ready为0，则将计算结果存入dout_store，并且进入到输出态。
- 输出态：dout=dout_store,out_valid=1,in_ready=in_valid。假如out_ready=1时，in_valid为1，则进入计算态进行下一轮计算；否则，进入闲置态。
在输出态的任何周期内，假如cancel被设为1，则out_valid不再设为1（同上），并且允许尽早开始下一轮计算。
- 计算单元应该具有“寄存器输出接入组合逻辑”的结构，例如，BRAM的输入线路可以直接作为din，因为BRAM可以被看成“一个寄存器的输出接到了一组数据选择器上，输出所选择的值”。

### 内存模型

QuSim使用一个比RVWMO还要弱的内存模型。
- 所有的内存读操作是乱序的，所有的内存写操作是顺序的，允许forwarding。因为是单核情况，所以不考虑同地址读取的乱序问题。
- 所有的IO操作都是强制顺序的：一条指令必须在其提交之前才能访问IO操作，并且这条指令的提交不能被中断或者异常打断。
- Fence指令只支持fence rwio, rwio，不提供更细粒度的内存围栏支持。
- Fence.I指令会导致Cache的写回。
- CSR寄存器强制顺序执行：只有当ROB为空的时候，才发射他们，且它们的提交不能被异常或中断打断（除非操作本身导致了异常）。
- Memory attribute：0x000000080000000开始的8M物理地址空间属于RAM，IO空间从0x0000000020000000开始，剩余的物理地址空间为空白。
## 组件清单
以下讨论QuSim用到的主要组件，其接口和主要设计思想，以及注意事项。
### IF-PC
PC是前端流水线的第一个元件，用于指向当前取指的目标。
PC的输出总是有效的，所以我们在这里略去out_valid信号，只使用out_ready信号控制其自增。
当分支预测失败或者分支预测需要跳转时，PC需要被置为新的值。PC的新取值由取指控制器决定。
### IF-TLB
IF-TLB对PC提供的地址进行TLB翻译操作。
最优情况下，ITLB命中，该级流水线需要一个周期；最差情况下，JTLB需要访问总线以实现TLB重填，需要若干周期。
IF-TLB可能被分支预测失败或者分支预测跳转影响，此时IF-TLB的操作需要被取消。取消信号由取指控制器决定。
IF-TLB可能会抛出以下异常：页表未命中、当前地址权限不足、地址未对齐（该种异常永远不应被提交，因为它一定是由于一个错误的taken-branch预测或者错误的jalr预测引起的）、物理地址不是内存。IF-TLB段的所有异常会流向下一级。
### IF-MEM
IF-MEM完成具体的访存操作。
最优情况下，L1 Cache命中，该级流水线需要一个周期；最差情况下，Cache需要访问总线，需要若干个周期。
IF-MEM可能被分支预测失败或者分支预测跳转所影响。
IF-MEM不会抛出新的异常，但是会把上一级传来的异常流到下一级。
### IF-QUEUE
IF-QUEUE是前端异步流水线的最后一级，用于对传来的指令进行译码、分支预测，以及暂存译码后的指令序列，用于传递给后端。
IF-QUEUE采用与其它流水级不同的就绪规则：在队列即将满时，IF-QUEUE会停止接收上一级的指令（in_ready=0），使得最后一条解码的指令流入队列后，队列恰好装满。
IF-QUEUE作为分支预测的所在点，可以取消前面的流水线操作（保证了“在分支预测完全正确的情况下，流入指令队列的指令恰好是完全正确的”），但是同时也可以被ROB带来的跳转取消并清空。

#### Decoder
针对RISC-V指令集的解码器。该解码器的框架是由一个简单的工具生成的，它将RISC-V指令翻译成更方便使用的形式（例如，附加了当前PC、取指异常类型、分支预测的结果等字段，并且将Rs、Rt、Rd设置为正确的值）。
Decoder被设计一个组合逻辑，但是它可以触发分支预测。分支预测的操作就是在这里完成的。
#### 对Branch指令的预测
Branch指令的跳转地址可以由指令本身和指令的PC简单计算出来，关键在于Branch是否被采用。我们使用一个2bit的饱和计数器预测Branch指令，并且在Branch指令被提交的时候更新这个计数器。
#### 对Jal/Jalr对的处理
Jal指令的跳转地址是已知的，但是Jalr指令的跳转地址是由寄存器的值决定的。这意味着我们不能很方便地预测Jalr的目的地址。
幸运的是，RISC-V规定，使用x1/x5寄存器作为“函数调用和返回”的Hint。这允许我们在涉及到x1/x5寄存器的Jal和Jalr指令时，使用一个“返回地址栈”进行分支预测：当Jal指令被认为是一个函数调用（rd为x1/x5）时，PC+4被压入栈中；当Jalr被认为时一个返回（rs为x1/x5）时，栈顶被从栈中挪出，作为分支预测的地址（大致如此，具体操作参考RISC-V文档）。
我们使用一个固定大小的栈来实现RAS，并且规定当栈满时，push操作会丢弃栈底的地址（使得最近的几次return能够正确，而较远的return分支预测失败）。当栈为空，或者源寄存器不是x1/x5时，我们使用“当前时刻寄存器中的值”作为猜测的跳转值。
然而，RAS要求我们为经过Decoder的所有指令操作返回地址栈，而经过Decoder的所有指令并非正确的指令序列。考虑如下的情形：
- 有一个Branch指令，taken时会跳过一个目标为x1地Jalr；Branch预测结果为not taken，而实际情况为taken。
- 错误指令流中的错误的Jalr从RAS里带走了一个元素。
- 发现Branch预测失败，但是最终返回地址栈错误地弹出了一个元素，导致接下来所有的返回操作都会因为错开了一个元素而预测错误。

为了避免无关因素干扰我们的返回地址预测，我们借助于将返回地址栈分两份存储来解决这个问题，记作RAS和影子RAS。
- 初始化时，RAS和影子RAS都清空。
- 所有经过Decoder的指令会按照规则更新影子RAS并且从影子RAS中取得分支预测地址，但是不会更新RAS。
- 所有被提交的指令会按照规则更新RAS。
- 当指令提交导致PC变化时（例如中断、异常、分支预测失败），将影子RAS的状态刷新到和RAS一致。

### IF-CONTROLLER
IF-CONTROLLER作为IF控制器，主要控制前端流水线各个流水级的取消操作。其本质是一个组合逻辑。
- 当发现来自ROB的跳转要求时，将IF-PC设为ROB要求的值，取消IF-TLB、IF-MEM，清空IF-QUEUE。
- 否则，当发现来自IF-QUEUE（Decoder）的分支预测跳转要求时，将IF-PC设为Decoder（分支预测器）要求的值，取消IF-TLB、IF-MEM。

### ITLB/DTLB/JTLB (TODO)
TLB被计划设计成一个二级缓存结构：第一级为一个直接映射的缓存，第二级被设计成一个全相联的缓存。
ITLB/DTLB缺失时，会向JTLB请求TLB表项（保证了ITLB/DTLB的内容一定在JTLB中）。JTLB缺失时，会调用Page Table Walker访问主存储器重填表项或者返回异常。

#### Page Table Walker (TODO)
Page Table Walker会直接访问内存来获得页表表项。其设计应该为一个简单的状态机，并且作为一个AXI Master出现。
Page Table Walker不设置缓存。在DRAM情形下，这可能会带来严重的效率损失：可能需要一个L2 Cache来提供加速。


### Dispatcher
Dispatcher与前端相连，将前端的指令分发到ROB、保留站、重命名站等若干位置。
#### 发射条件
Dispatcher需要保证所有的条件都满足时，才能向后端发射指令：
- rs_ready：保留站中存在空闲的本指令需要的FU。
- rob_ready：ROB没有被填满。
- store_queue_available：对于Store指令，SQ中必须有空闲项。
- load_queue_available：对于Load指令，LQ中必须有空闲项。
- rob_empty：有一些指令（例如CSR操作指令）需要在为ROB空的时候才能发射。
- no_immediate_cancel：下面一条指令不会立刻被重发射。当start_reissue并且当前指令依赖错误的Load指令时，不再发射该条指令。
#### 重发射相关
当Dispatcher接收到要求重发射的信号时，Dispatcher会停止从前端接收指令而从ROB接收指令，并且将其原样发射给ROB等元件。Dispatcher不需要知道重发射何时开始，故不需要接收start_reissue信号，只需要接收reissue信号。

#### 寄存器依赖与值的确定
Dispatcher通过复杂的组合逻辑确定指令的寄存器依赖关系和已知的值，并将其转交给保留站、ROB和寄存器重命名站。

- 如果操作数为常数，则操作数已知。
- 如果操作数所涉及的寄存器在重命名站里没有被重命名，则操作数在寄存器堆中。
	- 此时向寄存器堆的提交操作不可能指向这个寄存器。
- 如果操作数所涉及的寄存器在重命名站里被重命名，则依赖关系已知，操作数在ROB中，可能就绪或者未就绪。
	- 此时即使操作数即将被提交，其值也在ROB中；但是，依赖关系需要除去即将被提交的表项。
- 目标寄存器的依赖关系为两个操作数的依赖关系去除即将提交的依赖关系。
	- 假如即将提交的条目需要被重发射，那么新发射的指令也需要重发射。此时Dispatcher不再发射该条指令，而是在下一个周期直接开始重发射。
- 在ROB编号写入保留站时，如果CDB恰巧有输出，则覆盖掉ROB编号。

以上组合逻辑的critical path在于操作数——重命名站发现已重命名 ——ROB查询获得编号——保留站CDB覆盖，可能会造成较大的门延迟。
### Registers
寄存器堆。在编号上，我们不区分通用寄存器和浮点寄存器，二者采用统一编号，在译码时才将二者区分开（因此理论上后端可以执行“使用三个通用寄存器的浮点操作”，但是译码不会产生这种操作）。
寄存器堆接受来自ROB的写入，同时允许Dispatcher查询寄存器堆中的值。
由于Dispatch的依赖关系查询规则，寄存器堆不需要从写到读的Forward。

### RenameBuffer
寄存器重命名站保存当前的寄存器重命名状况：0号寄存器永远不会被重命名，其余寄存器在Dispatcher发射的时候会被重命名。当提交时，只有当当前寄存器仍然属于本表项，重命名站中的别名才会被抹去。
为了减少延迟，RenameBuffer中保存了当前寄存器对应表项的依赖Mask。0号寄存器永远没有依赖。
#### 重发射相关
RenameBuffer需要知道何时开始重新发射（start_reissue）：当需要重新发射时，RenameBuffer会完全清空。这样做的目的是，保证重发射的指令之间的正确依赖关系（当重发射开始时，ROB相当于为空，）


### ROB
Tomasulo算法的核心元件，存储正在乱序执行中的指令。

#### 指令发射
ROB需要从Dispatcher获知指令的内容以及依赖关系（ROB本身不计算指令的依赖关系）。同时，ROB允许Dispatcher查询自己的内容以提供给RS。假如指令不需要FU，则ValueReady会直接被置为1。

#### CDB
ROB需要从保留站接收计算结果，并且填入到ROB的表项中，同时记录ROB计算已经结束。特别地，对于Branch类指令其计算结果为1Bit表示是否跳转，对于Jump类指令会返回两个计算结果（NewPC表示跳转的结果，对于Jal一定等于PC+Imm，对于Jalr则为Rs+Imm；Value表示PC+4）。


#### PNR (Point of No Return)
绝大多数指令在提交之前是无害的，但是有一些指令除外：
- 对I/O区域的读操作。
- 对CSR的写操作会提前被完成。

我们规定，这些操作在提交时不能触发中断。

#### 指令提交
不同的指令会带来不同的指令提交行为，指令提交可能会触发异常、中断，或者分支预测失败等。

- Branch指令待提交时，需要判断分支地址与预测结果是否一致；若不一致，需要清空ROB并跳转到正确地址。
- Jump指令待提交时，需要判断跳转地址与预测结果时候一致；若不一致，需要清空ROB并跳转到正确地址。
- 浮点指令待提交时，需要将浮点异常写入浮点异常CSR。
- 发生异常的指令需要抛出异常。
- 没有越过PNR的指令提交时可以触发一个中断。
- Store指令需要在DCache/IO Buffer就绪后才能提交，并且会写入DCache或者写入IO Buffer。
- Fence.I指令提交时，需要写回DCache。
- SFence.VMA提交时，需要写回DCache并清空部分TLB。
- Load指令待提交时，需要检查Load Speculation是否正确；不正确的话，向外发送重发射开始信号，并从下个周期开始重发射流程。

#### 重发射
ROB负责指令重发射的调度。当ROB发现即将提交的Load Speculation失败时，下一周期开始ROB会进入重发射状态。
- ROB会自Load指令开始，将指令发射给Dispatcher。假如某条指令不需要重新发射（和Load没有数据依赖关系），那么其ROB表项（除了Mask）不会发生变化；否则，其ROB表项会在重发射时被重置。
- 对于不需要重新发射的指令，ROB会发出信号阻止RS接受指令，同时会阻止LQ/SQ清空原有数据。

### RS

